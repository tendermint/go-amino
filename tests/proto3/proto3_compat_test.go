// +build extensive_tests

// only built if manually enforced (via the build tag above)
package proto3

import (
	"testing"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/stretchr/testify/assert"

	"github.com/golang/protobuf/ptypes"
	p3 "github.com/tendermint/go-amino/tests/proto3/proto"

	"github.com/tendermint/go-amino"
)

// This file checks basic proto3 compatibility by checking encoding of some test-vectors generated by using protoc.

var cdc = amino.NewCodec()
var epoch time.Time

func init() {
	cdc.Seal()
	epoch, _ = time.Parse("2006-01-02 15:04:05 +0000 UTC", "1970-01-01 00:00:00 +0000 UTC")
}

func TestFixed32Roundtrip(t *testing.T) {
	// amino fixed32 (int32) <-> protbuf fixed32 (uint32)
	type testi32 struct {
		Int32 int32 `binary:"fixed32"`
	}
	ab, err := cdc.MarshalBinaryBare(testi32{Int32: 150})
	assert.NoError(t, err, "unexpected error")

	pb, err := proto.Marshal(&p3.TestInt32Fixed{Fixed32: 150})
	assert.NoError(t, err, "unexpected error")

	assert.Equal(t, pb, ab, "fixed32 (int32) encoding doesn't match")

	// unmarshal (from amino to proto and vice versa)
	var att testi32
	var pt p3.Test32
	err = proto.Unmarshal(ab, &pt)
	assert.NoError(t, err, "unexpected error")

	err = cdc.UnmarshalBinaryBare(pb, &att)
	assert.NoError(t, err, "unexpected error")

	assert.Equal(t, uint32(att.Int32), pt.Foo)
}

func TestVarintZigzagRoundtrip(t *testing.T) {
	// amino varint (int) <-> protobuf zigzag32 (int32)
	type testInt32Varint struct {
		Int32 int `binary:"varint"`
	}
	varint := testInt32Varint{Int32: 6000000}
	ab, err := cdc.MarshalBinaryBare(varint)
	assert.NoError(t, err, "unexpected error")
	pb, err := proto.Marshal(&p3.TestInt32Varint{Int32: 6000000})
	assert.NoError(t, err, "unexpected error")
	assert.Equal(t, pb, ab, "varint encoding doesn't match")

	var amToP3 p3.TestInt32Varint
	var p3ToAm testInt32Varint
	err = proto.Unmarshal(ab, &amToP3)
	assert.NoError(t, err, "unexpected error")

	err = cdc.UnmarshalBinaryBare(pb, &p3ToAm)
	assert.NoError(t, err, "unexpected error")

	assert.EqualValues(t, varint.Int32, amToP3.Int32)
}

func TestMixedFixedVarintRoudtrip(t *testing.T) {
	type test32 struct {
		Foo int32 `binary:"fixed32"`
		Bar int   `binary:"varint"`
	}
	ab, err := cdc.MarshalBinaryBare(test32{Foo: 150, Bar: 150})
	assert.NoError(t, err, "unexpected error")
	pb, err := proto.Marshal(&p3.Test32{Foo: 150, Bar: 150})
	assert.NoError(t, err, "unexpected error")
	assert.Equal(t, pb, ab, "mixed fixed32/varint encoding doesn't match")

	var amToP3 p3.Test32
	var p3ToAm test32
	err = proto.Unmarshal(ab, &amToP3)
	assert.NoError(t, err, "unexpected error")

	err = cdc.UnmarshalBinaryBare(pb, &p3ToAm)
	assert.NoError(t, err, "unexpected error")

	assert.EqualValues(t, p3ToAm.Foo, amToP3.Foo)

	// same as above but with skipped fields:
	ab, err = cdc.MarshalBinaryBare(test32{})
	assert.NoError(t, err, "unexpected error")
	pb, err = proto.Marshal(&p3.Test32{})
	assert.NoError(t, err, "unexpected error")
	assert.Len(t, pb, 0, "mixed fixed32/varint encoding doesn't match")
	assert.Len(t, ab, 0, "mixed fixed32/varint encoding doesn't match")

	err = proto.Unmarshal(ab, &amToP3)
	assert.NoError(t, err, "unexpected error")

	err = cdc.UnmarshalBinaryBare(pb, &p3ToAm)
	assert.NoError(t, err, "unexpected error")

	assert.EqualValues(t, p3ToAm.Foo, amToP3.Foo)
	assert.EqualValues(t, p3ToAm.Bar, amToP3.Bar)
}

func TestFixedU64Roundtrip(t *testing.T) {
	type testFixed64Uint struct {
		Int64 uint64 `binary:"fixed64"`
	}

	pvint64 := p3.TestFixedInt64{Int64: 150}
	avint64 := testFixed64Uint{Int64: 150}
	ab, err := cdc.MarshalBinaryBare(avint64)
	assert.NoError(t, err, "unexpected error")

	pb, err := proto.Marshal(&pvint64)
	assert.NoError(t, err, "unexpected error")

	assert.Equal(t, pb, ab, "fixed64 encoding doesn't match")

	var amToP3 p3.TestFixedInt64
	var p3ToAm testFixed64Uint
	err = proto.Unmarshal(ab, &amToP3)
	assert.NoError(t, err, "unexpected error")

	err = cdc.UnmarshalBinaryBare(pb, &p3ToAm)
	assert.NoError(t, err, "unexpected error")

	assert.EqualValues(t, p3ToAm.Int64, amToP3.Int64)
}

func TestProto3CompatPtrsRoundtrip(t *testing.T) {
	s := p3.SomeStruct{}

	ab, err := cdc.MarshalBinaryBare(s)
	assert.NoError(t, err)

	pb, err := proto.Marshal(&s)
	assert.NoError(t, err)
	// This fails as amino currently returns []byte(nil)
	// while protobuf returns []byte{}:
	//
	// assert.Equal(t, ab, pb)
	//
	// Semantically, that's no problem though. Hence, we only check for zero length:
	assert.Zero(t, len(ab), "expected an empty encoding for a nil pointer")
	t.Log(ab)

	var amToP3 p3.SomeStruct
	var p3ToAm p3.SomeStruct
	err = proto.Unmarshal(ab, &amToP3)
	assert.NoError(t, err, "unexpected error")

	err = cdc.UnmarshalBinaryBare(pb, &p3ToAm)
	assert.NoError(t, err, "unexpected error")

	assert.EqualValues(t, p3ToAm, amToP3)

	s2 := p3.SomeStruct{Emb: &p3.EmbeddedStruct{}}

	ab, err = cdc.MarshalBinaryBare(s2)
	assert.NoError(t, err)

	pb, err = proto.Marshal(&s2)
	assert.NoError(t, err)
	assert.Equal(t, ab, pb)

	err = proto.Unmarshal(ab, &amToP3)
	assert.NoError(t, err, "unexpected error")

	err = cdc.UnmarshalBinaryBare(pb, &p3ToAm)
	assert.NoError(t, err, "unexpected error")

	assert.EqualValues(t, p3ToAm, amToP3)

	assert.NotZero(t, len(ab), "expected a non-empty encoding for a non-nil pointer to an empty struct")
	t.Log(ab)

}

// ---------------------------------------------------------------
//  ---- time.Time <-> timestamp.Timestamp (proto3 well known type) :
// ---------------------------------------------------------------

// equivalent go struct or "type" to the proto3 message:
type goAminoGotTime struct {
	T *time.Time
}

func TestProto3CompatEmptyTimestamp(t *testing.T) {
	empty := p3.ProtoGotTime{}
	// protobuf also marshals to empty bytes here:
	pb, err := proto.Marshal(&empty)
	assert.NoError(t, err)
	assert.Len(t, pb, 0)

	// unmarshaling an empty slice behaves a bit differently in proto3 compared to amino:
	res := &goAminoGotTime{}
	err = cdc.UnmarshalBinaryBare(pb, res)
	assert.NoError(t, err)
	// NOTE: this behaves differently because amino defaults the time to 1970-01-01 00:00:00 +0000 UTC while
	// decoding; protobuf defaults to nil here (see the following lines below):
	assert.NoError(t, err)
	assert.Equal(t, goAminoGotTime{T: &epoch}, *res)
	pbRes := p3.ProtoGotTime{}
	err = proto.Unmarshal(pb, &pbRes)
	assert.NoError(t, err)
	assert.Equal(t, p3.ProtoGotTime{T: nil}, pbRes)
}

func TestProto3CompatTimestampNow(t *testing.T) {
	// test with current time:
	now := time.Now()
	ptts, err := ptypes.TimestampProto(now)
	assert.NoError(t, err)
	pt := p3.ProtoGotTime{T: ptts}
	at := goAminoGotTime{T: &now}
	ab1, err := cdc.MarshalBinaryBare(at)
	assert.NoError(t, err)
	ab2, err := cdc.MarshalBinaryBare(pt)
	assert.NoError(t, err)
	// amino's encoding of time.Time is the same as proto's encoding of the well known type
	// timestamp.Timestamp (they can be used interchangeably):
	assert.NotEqual(t, ab1, ab2)
	pb, err := proto.Marshal(&pt)
	assert.NoError(t, err)
	assert.Equal(t, ab1, pb)

	pbRes := p3.ProtoGotTime{}
	err = proto.Unmarshal(ab1, &pbRes)
	assert.NoError(t, err)
	got, err := ptypes.Timestamp(pbRes.T)
	assert.NoError(t, err)
	_, err = ptypes.TimestampProto(now)
	assert.NoError(t, err)
	err = proto.Unmarshal(pb, &pbRes)
	assert.NoError(t, err)
	// create time.Time from timestamp.Timestamp and check if they are the same:
	got, err = ptypes.Timestamp(pbRes.T)
	assert.Equal(t, got.UTC(), now.UTC())
}


func TestProto3EpochTime(t *testing.T) {
	pbRes := p3.ProtoGotTime{}
	// amino encode epoch (1970) and decode using proto; expect the resulting time to be epoch again:
	ab, err := cdc.MarshalBinaryBare(goAminoGotTime{T: &epoch})
	assert.NoError(t, err)
	err = proto.Unmarshal(ab, &pbRes)
	assert.NoError(t, err)
	ts, err := ptypes.Timestamp(pbRes.T)
	assert.NoError(t, err)
	assert.EqualValues(t, ts, epoch)
}

func TestProtoNegativeSeconds(t *testing.T) {
	pbRes := p3.ProtoGotTime{}
	// test with negative seconds (0001-01-01 -> seconds = -62135596800, nanos = 0):
	ntm, err := time.Parse("2006-01-02 15:04:05 +0000 UTC", "0001-01-01 00:00:00 +0000 UTC")
	ab, err := cdc.MarshalBinaryBare(goAminoGotTime{T: &ntm})
	assert.NoError(t, err)
	res := &goAminoGotTime{}
	err = cdc.UnmarshalBinaryBare(ab, res)
	assert.NoError(t, err)
	assert.EqualValues(t, ntm, *res.T)
	err = proto.Unmarshal(ab, &pbRes)
	assert.NoError(t, err)
	got, err := ptypes.Timestamp(pbRes.T)
	assert.NoError(t, err)
	assert.Equal(t, got, ntm)
}

// the following two tests documents the underlying encoding / decoding of seconds and nanos in amino:

func TestProtoInt32(t *testing.T) {
	// proto has to types for negative numbers
	// int32 and sint32
	// the latter is more efficient for negative numbers

	// the equivalent go type / struct:
	type TestInt32 struct {
		// this is an uint64 to force amino encode this the same as proto treats int32:
		Int32 uint64
	}
	ptc := p3.TestInt32{
		// proto3's int32 -> is a golang int32 but get's encoded as a amino encodes uint32 (see above struct)
		Int32: -153621037,
	}

	pb, err := proto.Marshal(&ptc)
	assert.NoError(t, err)
	cdc := amino.NewCodec()
	ab, err := cdc.MarshalBinaryBare(TestInt32{uint64(ptc.Int32)})
	assert.NoError(t, err)

	assert.Equal(t, pb, ab)

	got := &TestInt32{}
	err = cdc.UnmarshalBinaryBare(ab, got)
	assert.NoError(t, err)
	// currently, the only way to get back the orig. negative value in amino is to cast to int32:
	assert.Equal(t, int32(got.Int32), ptc.Int32)
}

func TestProtoInt64(t *testing.T) {
	// same test as the one above but with
	type TestInt64 struct {
		Int64 uint64
	}
	ptc := p3.TestInt64{
		Int64: int64(-int(^uint(0)  >> 1) - 1), // -9223372036854775808
	}

	pb, err := proto.Marshal(&ptc)
	assert.NoError(t, err)
	cdc := amino.NewCodec()
	ab, err := cdc.MarshalBinaryBare(TestInt64{uint64(ptc.Int64)})
	assert.NoError(t, err)
	assert.Equal(t, pb, ab)

	got := &TestInt64{}
	err = cdc.UnmarshalBinaryBare(ab, got)
	assert.NoError(t, err)
	// cast back to int64 to get back the orig negative value:
	assert.Equal(t, int64(got.Int64), ptc.Int64)
}
